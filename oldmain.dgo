package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"runtime"
	"strings"

	"github.com/nlopes/slack"
	"github.com/spf13/viper"
)

type BotCentral struct {
	Channel *slack.Channel
	Event   *slack.MessageEvent
	UserID  string
}

type AttachmentChannel struct {
	Channel      *slack.Channel
	Attachment   *slack.Attachment
	DisplayTitle string
}

type Handler struct {
	Prefix         string
	HandlerChannel chan BotCentral
}

type Handlers []Handler

var (
	//BotID the userid for our bot
	botID           string
	botReplyChannel chan AttachmentChannel
	handlerMatrix   Handlers
	api             *slack.Client
)

func main() {
	// set maxprocs to the number of cpus we are running with
	runtime.GOMAXPROCS(runtime.NumCPU())

	// let's get viper to read the config file
	initializeConfig()

	// open the logfiles
	l := openLogfile(viper.GetString("log_file"))
	m := openLogfile(viper.GetString("message_log"))

	// setup the logger
	logger := log.New(l, "slack-bot: ", log.Lshortfile|log.LstdFlags)
	message_logger := log.New(m, "slack-message", log.Lshortfile|log.LstdFlags)

	// instantiate the new slack interface
	api = slack.New(viper.GetString("slack_token"))

	// assing a logger to it
	slack.SetLogger(logger)

	//set debugging according to the specification in the config file
	api.SetDebug(viper.GetBool("slack_debug"))

	//get a new real time messaging connection
	rtm := api.NewRTM()

	botReplyChannel = make(chan AttachmentChannel)
	go rtm.ManageConnection()

	// initialize the simpel handler
	handlerMatrix = append(handlerMatrix, initSimpleHandler(botReplyChannel))

	go handleBotReply(botReplyChannel)

	for msg := range rtm.IncomingEvents {
		fmt.Print("Event Received: ")
		switch ev := msg.Data.(type) {
		case *slack.HelloEvent:
			// Ignore hello

		case *slack.ConnectedEvent:
			fmt.Println("Infos:", ev.Info)
			fmt.Println("Connection counter:", ev.ConnectionCount)
			// Replace #general with your Channel ID
			rtm.SendMessage(rtm.NewOutgoingMessage("Hello world", "#general"))
			botID = ev.Info.User.ID

		case *slack.MessageEvent:
			fmt.Printf("Message: %v\n", ev)
			message_logger.Printf("%v\n", ev)

			channelInfo, err := api.GetChannelInfo(ev.Channel)
			if err != nil {
				log.Fatalln(err)
			}

			botCentral := &BotCentral{
				Channel: channelInfo,
				Event:   ev,
				UserID:  ev.User,
			}

			if ev.Type == "message" && strings.HasPrefix(ev.Text, "<@"+botID+">") {

				commandArray := strings.Fields(ev.Text)
				for _, c := range handlerMatrix {
					if c.Prefix == commandArray[1] {
						fmt.Printf("%v\n", c)
						c.HandlerChannel <- *botCentral

					}
				}
			}

		case *slack.PresenceChangeEvent:
			fmt.Printf("Presence Change: %v\n", ev)

		case *slack.LatencyReport:
			fmt.Printf("Current latency: %v\n", ev.Value)

		case *slack.RTMError:
			fmt.Printf("Error: %s\n", ev.Error())

		case *slack.InvalidAuthEvent:
			fmt.Printf("Invalid credentials")
			return

		default:

			// Ignore other events..
			// fmt.Printf("Unexpected: %v\n", msg.Data)
		}
	}
}

func initializeConfig() {
	// get input from config files

	// configfile name is barney
	viper.SetConfigName("slacksmurf")

	// add the filepaths that will be used
	viper.AddConfigPath("/etc/slacksmurf/")
	viper.AddConfigPath("$HOME/.slacksmurf")
	viper.AddConfigPath(".")

	// Handle errors reading the config file
	err := viper.ReadInConfig()
	if err != nil {
		//debugInfo := viper.Debug()
		fmt.Printf("Fatal error config file: %s \n", err)
	}

}

func openLogfile(filename string) io.Writer {
	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		fmt.Printf("error opening file %s: %v", filename, err)
		os.Exit(-1)
	}

	return f
}

func initSimpleHandler(c chan AttachmentChannel) Handler {
	simpleChannel := make(chan BotCentral)
	go simpleHandler(c, simpleChannel)
	h := Handler{
		Prefix:         "simple",
		HandlerChannel: simpleChannel,
	}
	return h
}

func simpleHandler(c chan AttachmentChannel, bc chan BotCentral) {
	commands := map[string]string{
		"help": "See the available bot commands.",
		"mean": "See how the rating of the selected user looks like, comparing to the mean of all users.",
	}

	//retrieve own handler

	var attachmentChannel AttachmentChannel
	for {

		botChannel := <-bc
		attachmentChannel.DisplayTitle = "Simple helper"
		fmt.Printf("%v\n", botChannel)
		attachmentChannel.Channel = botChannel.Channel
		commandArray := strings.Fields(botChannel.Event.Text)
		fmt.Println(commandArray)
		switch commandArray[2] {

		case "help":
			fmt.Println("test")
			fields := make([]slack.AttachmentField, 0)
			for k, v := range commands {
				fields = append(fields, slack.AttachmentField{
					Title: "<bot> " + k,
					Value: v,
				})

			}
			attachment := &slack.Attachment{
				Pretext: "Guru Command List",
				Color:   "#B733FF",
				Fields:  fields,
			}
			fmt.Printf("%v\n", attachment)
			attachmentChannel.Attachment = attachment
			c <- attachmentChannel
		default:
			fmt.Println("default")
		}
	}
}

func handleBotReply(c chan AttachmentChannel) {
	for {
		ac := <-c
		params := slack.PostMessageParameters{}
		params.AsUser = true
		params.Attachments = []slack.Attachment{*ac.Attachment}
		_, _, errPostMessage := api.PostMessage(ac.Channel.Name, ac.DisplayTitle, params)
		if errPostMessage != nil {
			log.Fatal(errPostMessage)
		}
	}
}
